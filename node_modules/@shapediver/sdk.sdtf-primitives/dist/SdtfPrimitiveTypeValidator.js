"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdtfPrimitiveTypeValidator = void 0;
const sdk_sdtf_core_1 = require("@shapediver/sdk.sdtf-core");
const decimal_js_1 = require("decimal.js");
const SdtfPrimitiveTypeGuard_1 = require("./SdtfPrimitiveTypeGuard");
const UUIDv4_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
const SINGLE_MAX = new decimal_js_1.Decimal(3.40282347E+38);
const SINGLE_MIN = new decimal_js_1.Decimal(-3.40282347E+38);
/** Validates values that are of a type hint supported by this integration. */
class SdtfPrimitiveTypeValidator {
    /**
     * Validates the given component of the given type.
     * @throws {@link SdtfError} when the given type is not supported.
     */
    validateComponent(typeHint, value, accessor) {
        switch (typeHint) {
            case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.BOOLEAN:
                return SdtfPrimitiveTypeGuard_1.SdtfPrimitiveTypeGuard.isBoolean(value);
            case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.CHAR:
                return SdtfPrimitiveTypeValidator.validateCharType(value);
            case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.COLOR:
                return SdtfPrimitiveTypeValidator.validateColorType(value);
            case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.DATA:
                return !!accessor && value === undefined;
            case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.DECIMAL:
                return SdtfPrimitiveTypeGuard_1.SdtfPrimitiveTypeGuard.isNumber(value);
            case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.DOUBLE:
                return SdtfPrimitiveTypeGuard_1.SdtfPrimitiveTypeGuard.isNumber(value);
            case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.GUID:
                return SdtfPrimitiveTypeValidator.validateGuidType(value);
            case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.IMAGE:
                return !!accessor && value === undefined;
            case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.INT8:
                return SdtfPrimitiveTypeValidator.validateInt8Type(value);
            case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.INT16:
                return SdtfPrimitiveTypeValidator.validateInt16Type(value);
            case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.INT32:
                return SdtfPrimitiveTypeValidator.validateInt32Type(value);
            case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.INT64:
                return SdtfPrimitiveTypeValidator.validateInt64Type(value);
            case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.JSON:
                return SdtfPrimitiveTypeGuard_1.SdtfPrimitiveTypeGuard.isJson(value);
            case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.SINGLE:
                return SdtfPrimitiveTypeValidator.validateSingleType(value);
            case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.STRING:
                return SdtfPrimitiveTypeGuard_1.SdtfPrimitiveTypeGuard.isString(value);
            case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.UINT8:
                return SdtfPrimitiveTypeValidator.validateUint8Type(value);
            case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.UINT16:
                return SdtfPrimitiveTypeValidator.validateUint16Type(value);
            case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.UINT32:
                return SdtfPrimitiveTypeValidator.validateUint32Type(value);
            case sdk_sdtf_core_1.SdtfPrimitiveTypeHintName.UINT64:
                return SdtfPrimitiveTypeValidator.validateUint64Type(value);
            default:
                (0, sdk_sdtf_core_1.sdAssertUnreachable)(typeHint);
        }
    }
    /** Returns `true` when the given value is a valid `SdtfPrimitiveTypeHintName.CHAR` type, otherwise `false`. */
    static validateCharType(value) {
        return SdtfPrimitiveTypeGuard_1.SdtfPrimitiveTypeGuard.isString(value) && value.length === 1;
    }
    /**
     * Returns `true` when the given value is a valid `SdtfPrimitiveTypeHintName.COLOR` type.
     *
     * NOTE:
     * The validator excepts both color types, regular (4 parts) and legacy (3 parts). However, a
     * legacy color is later on mapped to a regular color structure.
     */
    static validateColorType(value) {
        // Validate color array
        if ((0, sdk_sdtf_core_1.isNumberArray)(value) && value.length >= 3 && value.length <= 4)
            return true;
        // Legacy colors are represented by a string
        if (typeof value !== "string")
            return false;
        const parts = value.split(",");
        return (parts.length === 3 || parts.length === 4) && parts.every(p => (0, sdk_sdtf_core_1.isNumeric)(p));
    }
    /** Returns `true` when the given value is a valid `SdtfPrimitiveTypeHintName.GUID` type, otherwise `false`. */
    static validateGuidType(value) {
        return SdtfPrimitiveTypeGuard_1.SdtfPrimitiveTypeGuard.isString(value) && UUIDv4_REGEX.test(value);
    }
    /** Returns `true` when the given value is a valid `SdtfPrimitiveTypeHintName.INT8` type, otherwise `false`. */
    static validateInt8Type(value) {
        return (0, sdk_sdtf_core_1.isInt)(value) && value >= -128 && value <= 127;
    }
    /** Returns `true` when the given value is a valid `SdtfPrimitiveTypeHintName.INT16` type, otherwise `false`. */
    static validateInt16Type(value) {
        return (0, sdk_sdtf_core_1.isInt)(value) && value >= -32768 && value <= 32767;
    }
    /** Returns `true` when the given value is a valid `SdtfPrimitiveTypeHintName.INT32` type, otherwise `false`. */
    static validateInt32Type(value) {
        return (0, sdk_sdtf_core_1.isInt)(value) && value >= -2147483648 && value <= 2147483647;
    }
    /** Returns `true` when the given value is a valid `SdtfPrimitiveTypeHintName.INT64` type, otherwise `false`. */
    static validateInt64Type(value) {
        return (0, sdk_sdtf_core_1.isInt)(value) && value >= -9223372036854775808 && value <= 9223372036854775807;
    }
    /**
     * Returns `true` when the given value is a valid `SdtfPrimitiveTypeHintName.SINGLE` type, otherwise `false`.
     *
     * NOTE:
     * The validation does only a rough check if the precision does not exceed 9 digits.
     * However, this might still lead to a loss in precision due to the nature of single-precision floating points.
     */
    static validateSingleType(value) {
        if (!(0, sdk_sdtf_core_1.isNumber)(value))
            return false;
        const decimal = new decimal_js_1.Decimal(value);
        return decimal.precision() <= 9 &&
            decimal.comparedTo(SINGLE_MIN) >= 0 &&
            decimal.comparedTo(SINGLE_MAX) <= 0;
    }
    /** Returns `true` when the given value is a valid `SdtfPrimitiveTypeHintName.UINT8` type, otherwise `false`. */
    static validateUint8Type(value) {
        return (0, sdk_sdtf_core_1.isUint)(value) && value <= 255;
    }
    /** Returns `true` when the given value is a valid `SdtfPrimitiveTypeHintName.UINT16` type, otherwise `false`. */
    static validateUint16Type(value) {
        return (0, sdk_sdtf_core_1.isUint)(value) && value <= 65535;
    }
    /** Returns `true` when the given value is a valid `SdtfPrimitiveTypeHintName.UINT32` type, otherwise `false`. */
    static validateUint32Type(value) {
        return (0, sdk_sdtf_core_1.isUint)(value) && value <= 4294967295;
    }
    /**
     * Returns `true` when the given value is a valid `SdtfPrimitiveTypeHintName.UINT64` type, otherwise `false`.
     *
     * WARNING:
     * Max safe integer in JavaScript is `9007199254740991`, while uint64 limit is `18446744073709551615`.
     * Thus, numbers bigger than safe integer are automatically mapped to `Number.Infinity`.
     */
    static validateUint64Type(value) {
        return (0, sdk_sdtf_core_1.isUint)(value);
    }
}
exports.SdtfPrimitiveTypeValidator = SdtfPrimitiveTypeValidator;
//# sourceMappingURL=SdtfPrimitiveTypeValidator.js.map