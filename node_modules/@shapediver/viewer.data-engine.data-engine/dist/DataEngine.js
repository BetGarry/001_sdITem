"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataEngine = void 0;
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const viewer_data_engine_geometry_engine_1 = require("@shapediver/viewer.data-engine.geometry-engine");
const viewer_data_engine_material_engine_1 = require("@shapediver/viewer.data-engine.material-engine");
const viewer_data_engine_sdtf_engine_1 = require("@shapediver/viewer.data-engine.sdtf-engine");
const viewer_data_engine_tag3d_engine_1 = require("@shapediver/viewer.data-engine.tag3d-engine");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_data_engine_html_element_anchor_engine_1 = require("@shapediver/viewer.data-engine.html-element-anchor-engine");
const gl_matrix_1 = require("gl-matrix");
class DataEngine {
    constructor() {
        // #region Properties (7)
        this._geometryEngine = viewer_data_engine_geometry_engine_1.GeometryEngine.instance;
        this._htmlElementAnchorEngine = viewer_data_engine_html_element_anchor_engine_1.HTMLElementAnchorEngine.instance;
        this._logger = viewer_shared_services_1.Logger.instance;
        this._materialEngine = viewer_data_engine_material_engine_1.MaterialEngine.instance;
        this._sdtfEngine = viewer_data_engine_sdtf_engine_1.SDTFEngine.instance;
        this._tag3dEngine = viewer_data_engine_tag3d_engine_1.Tag3dEngine.instance;
        // #endregion Public Methods (1)
    }
    // #endregion Properties (7)
    // #region Public Static Accessors (1)
    static get instance() {
        return this._instance || (this._instance = new this());
    }
    // #endregion Public Static Accessors (1)
    // #region Public Methods (1)
    loadContent(content, jwtToken) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!content || (content && !content.format))
                throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError('DataEngine cannot load content.');
            let node;
            if (content.format === 'glb' || content.format === 'gltf') {
                node = yield this._geometryEngine.loadContent(content);
            }
            else if (content.format === 'material') {
                node = yield this._materialEngine.loadContent(content);
            }
            else if (content.format === 'tag2d' || content.format === 'anchor') {
                node = yield this._htmlElementAnchorEngine.loadContent(content);
            }
            else if (content.format === 'tag3d') {
                node = yield this._tag3dEngine.loadContent(content);
            }
            else if (content.format === 'sdtf') {
                node = yield this._sdtfEngine.loadContent(content, jwtToken);
            }
            else {
                node = new viewer_shared_node_tree_1.TreeNode('custom');
                node.data.push(new viewer_shared_types_1.CustomData(Object.assign({}, content)));
            }
            const transformationNode = new viewer_shared_node_tree_1.TreeNode('transformation');
            if (content.transformations && Array.isArray(content.transformations)) {
                for (let i = 0; i < content.transformations.length; i++) {
                    const t = content.transformations[i];
                    if (Array.isArray(t) && t.length === 16) {
                        const nodeInstance = node.clone();
                        nodeInstance.transformations = [{
                                id: 'content_' + i,
                                matrix: gl_matrix_1.mat4.fromValues(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15])
                            }].concat(node.transformations);
                        transformationNode.updateVersion();
                        transformationNode.addChild(nodeInstance);
                    }
                }
            }
            else {
                transformationNode.addChild(node);
            }
            return transformationNode;
        });
    }
}
exports.DataEngine = DataEngine;
//# sourceMappingURL=DataEngine.js.map