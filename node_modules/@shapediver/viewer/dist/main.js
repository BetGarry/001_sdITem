"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createViewport = exports.createSession = exports.generalOptions = exports.sessions = exports.viewports = exports.sceneTree = exports.removeListener = exports.addListener = void 0;
const viewer_rendering_engine_rendering_engine_1 = require("@shapediver/viewer.rendering-engine.rendering-engine");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_shared_services_2 = require("@shapediver/viewer.shared.services");
const viewer_shared_services_3 = require("@shapediver/viewer.shared.services");
const viewer_main_creation_control_center_1 = require("@shapediver/viewer.main.creation-control-center");
const ViewportApi_1 = require("./implementation/viewport/ViewportApi");
const SessionApi_1 = require("./implementation/session/SessionApi");
const viewer_shared_build_data_1 = require("@shapediver/viewer.shared.build-data");
const viewer_data_engine_geometry_engine_1 = require("@shapediver/viewer.data-engine.geometry-engine");
const creationControlCenter = viewer_main_creation_control_center_1.CreationControlCenter.instance;
const inputValidator = viewer_shared_services_3.InputValidator.instance;
const logger = viewer_shared_services_2.Logger.instance;
const eventEngine = viewer_shared_services_1.EventEngine.instance;
const geometryEngine = viewer_data_engine_geometry_engine_1.GeometryEngine.instance;
let createdConsoleMessage = false, consoleBranding = true;
class GeneralOptions {
    // #region Public Accessors (4)
    get loggingLevel() {
        return logger.loggingLevel;
    }
    set loggingLevel(value) {
        inputValidator.validateAndError('loggingLevel', value, 'enum', true, Object.values(viewer_shared_services_1.LOGGING_LEVEL));
        logger.loggingLevel = value;
        logger.debug(`loggingLevel: LoggingLevel was set to: ${value}`);
    }
    get showMessages() {
        return logger.showMessages;
    }
    set showMessages(value) {
        inputValidator.validateAndError('showMessages', value, 'boolean');
        logger.showMessages = value;
        logger.debug(`showMessages: ShowMessages was set to: ${value}`);
    }
    get parallelGlTFProcessing() {
        return geometryEngine.parallelGlTFProcessing;
    }
    set parallelGlTFProcessing(value) {
        inputValidator.validateAndError('parallelGlTFProcessing', value, 'number');
        geometryEngine.parallelGlTFProcessing = value;
        logger.debug(`parallelGlTFProcessing: ParallelGlTFProcessing was set to: ${value}`);
    }
    get consoleBranding() {
        return consoleBranding;
    }
    set consoleBranding(value) {
        inputValidator.validateAndError('consoleBranding', value, 'boolean');
        consoleBranding = value;
        logger.debug(`consoleBranding: ConsoleBranding was set to: ${value}`);
    }
}
/**
 * Adds an event listener.
 *
 * @param type The type of event.
 * @param cb The callback.
 * @returns
 */
const addListener = (type, cb) => {
    inputValidator.validateAndError(`addListener`, type, 'string');
    inputValidator.validateAndError(`addListener`, cb, 'function');
    logger.debug(`addListener: Event Listener was registered for ${type}.`);
    return eventEngine.addListener(type, cb);
};
exports.addListener = addListener;
/**
 * Removes an event listener.
 *
 * @param id The id of the listener.
 * @returns
 */
const removeListener = (id) => {
    inputValidator.validateAndError(`removeListener`, id, 'string');
    logger.debug(`removeListener: Removing event listener with id ${id}.`);
    return eventEngine.removeListener(id);
};
exports.removeListener = removeListener;
/**
 * The scene tree that is used to store the scene.
 * The scene tree contains a unique node and child nodes for each session,
 * and can also be used to add your own nodes.
 */
exports.sceneTree = viewer_shared_node_tree_1.Tree.instance;
/**
 * The viewports that are currently being used.
 */
exports.viewports = {};
/**
 * The sessions that are currently being used.
 */
exports.sessions = {};
// Whenever a session or viewport is added or removed, this update is called.
creationControlCenter.update = (sessionEngines, renderingEngines) => {
    for (let s in sessionEngines)
        if (!exports.sessions[s])
            exports.sessions[s] = new SessionApi_1.SessionApi(sessionEngines[s]);
    for (let s in exports.sessions)
        if (!sessionEngines[s])
            delete exports.sessions[s];
    for (let v in renderingEngines)
        if (!exports.viewports[v])
            exports.viewports[v] = new ViewportApi_1.ViewportApi(renderingEngines[v]);
    for (let v in exports.viewports) {
        if (!renderingEngines[v])
            delete exports.viewports[v];
    }
};
const showConsoleMessage = () => {
    createdConsoleMessage = true;
    if (consoleBranding === true) {
        console.log(`Powered by:
   _____  __                         ____   _                   
  / ___/ / /_   ____ _ ____   ___   / __ \\ (_)_   __ ___   _____
  \\__ \\ / __ \\ / __ '// __ \\ / _ \\ / / / // /| | / // _ \\ / ___/
 ___/ // / / // /_/ // /_/ //  __// /_/ // / | |/ //  __// /    
/____//_/ /_/ \\__,_// .___/ \\___//_____//_/  |___/ \\___//_/     
                   /_/                                          
ShapeDiver Viewer 3, Version ${viewer_shared_build_data_1.build_data.build_version.replace('3.', '')}
Visit us at https://shapediver.com/ and find out more!
`);
    }
    else {
        console.log(`ShapeDiver Viewer 3, Version ${viewer_shared_build_data_1.build_data.build_version.replace('3.', '')}`);
    }
};
/**
 * General Viewer options that are used everywhere.
 * - loggingLevel: The logging level that is used.
 * - showMessages: Option to show/hide messages in the browser console.
 */
exports.generalOptions = new GeneralOptions();
/**
 * Create and initialize a session with a model hosted on a
 * {@link https://help.shapediver.com/doc/Geometry-Backend.1863942173.html|ShapeDiver Geometry Backend},
 * using the provided ticket and modelViewUrl.
 * Returns a session api object allowing to control the session.
 *
 * A JWT can be specified for authorizing the API calls to the Geometry Backend.
 * The model's settings on the Geometry Backend might require a JWT to be provided.
 *
 * By default the outputs of the model for its default parameter values will be loaded.
 *
 * An optional identifier for the session can be provided. This identifier can be used to retrieve the
 * api object from {@link sessions}. In case no identifier is provided, a unique one will be generated.
 *
 * @param properties.ticket The ticket for direct embedding of the model to create a session for. This identifies the model on the Geometry Backend.
 * @param properties.modelViewUrl The modelViewUrl of the {@link https://help.shapediver.com/doc/Geometry-Backend.1863942173.html|ShapeDiver Geometry Backend} hosting the model.
 * @param properties.jwtToken The JWT to use for authorizing the API calls to the Geometry Backend.
 * @param properties.id The unique identifier to use for the session.
 * @param properties.waitForOutputs Option to wait for the outputs to be loaded, or return immediately after creation of the session. (default: true)
 * @param properties.loadOutputs Option to load the outputs, or not load them until the first call of {@link ISessioncustomize}. (default: true)
 * @param properties.excludeViewports Option to exclude some viewports from the start. Can be accessed via {@link ISessionexcludeViewports}.
 * @param properties.initialParameterValues The initial set of parameter values to use. Map from parameter id to parameter value. The default value will be used for any parameter not specified.
 * @returns
 */
const createSession = (properties) => __awaiter(void 0, void 0, void 0, function* () {
    if (createdConsoleMessage === false)
        showConsoleMessage();
    logger.info(`createSession: Creating and initializing session with properties ${JSON.stringify(properties)}.`);
    // input validation
    inputValidator.validateAndError(`createSession`, properties, 'object');
    inputValidator.validateAndError(`createSession`, properties.ticket, 'string');
    inputValidator.validateAndError(`createSession`, properties.modelViewUrl, 'string');
    inputValidator.validateAndError(`createSession`, properties.jwtToken, 'string', false);
    inputValidator.validateAndError(`createSession`, properties.id, 'string', false);
    inputValidator.validateAndError(`createSession`, properties.waitForOutputs, 'boolean', false);
    inputValidator.validateAndError(`createSession`, properties.loadOutputs, 'boolean', false);
    inputValidator.validateAndError(`createSession`, properties.excludeViewports, 'stringArray', false);
    inputValidator.validateAndError(`createSession`, properties.initialParameterValues, 'object', false);
    if (properties.initialParameterValues)
        for (let p in properties.initialParameterValues)
            inputValidator.validateAndError(`createSession`, properties.initialParameterValues[p], 'string');
    if (properties.waitForOutputs === undefined)
        properties.waitForOutputs = true;
    if (properties.loadOutputs === undefined)
        properties.loadOutputs = true;
    const sessionEngine = yield creationControlCenter.createSessionEngine(properties);
    exports.sessions[sessionEngine.id] = new SessionApi_1.SessionApi(sessionEngine);
    return exports.sessions[sessionEngine.id];
});
exports.createSession = createSession;
/**
 * Create and initialize a viewport with the provided type and canvas,
 * and return a viewport api object allowing to control it.
 *
 * An optional identifier for the viewport can be provided. This identifier can be used to retrieve the
 * viewport object from {@link viewports}. In case no identifier is provided, a unique one will be generated.
 *
 * By default a new viewport displays the complete scene tree. Viewports can be excluded from
 * displaying geometry for specific sessions by using the {@link excludeViewports} property of
 * {@link ISessionApi}.
 *
 * @param properties.visibility The visibility of the viewport.
 * @param properties.canvas The canvas that the viewport should use. A canvas element will be created if none is provided.
 * @param properties.id The unique identifier to use for the viewport.
 * @param properties.branding Optional branding options.
 * @param properties.sessionSettingsId Optional identifier of the session to be used for loading / persisting settings of the viewport when the {@link SESSION_SETTINGS_MODE} is set to MANUAL.
 * @param properties.sessionSettingsMode Allows to control which session to use for loading / persisting settings of the viewport. (default: {@link SESSION_SETTINGS_MODE.FIRST}).
 * @returns
 */
const createViewport = (properties) => __awaiter(void 0, void 0, void 0, function* () {
    if (createdConsoleMessage === false)
        showConsoleMessage();
    inputValidator.validateAndError('createViewport', properties, 'object', false);
    const prop = Object.assign({}, properties);
    inputValidator.validateAndError(`createViewport`, prop.canvas, 'HTMLCanvasElement', false);
    inputValidator.validateAndError(`createViewport`, prop.id, 'string', false);
    inputValidator.validateAndError(`createViewport`, prop.sessionSettingsId, 'string', false);
    inputValidator.validateAndError(`createViewport`, prop.sessionSettingsMode, 'enum', false, Object.values(viewer_rendering_engine_rendering_engine_1.SESSION_SETTINGS_MODE));
    inputValidator.validateAndError(`createViewport`, prop.visibility, 'enum', false, Object.values(viewer_rendering_engine_rendering_engine_1.VISIBILITY_MODE));
    inputValidator.validateAndError('createViewport', prop.branding, 'object', false);
    const branding = Object.assign({}, prop.branding);
    if (branding.logo !== null)
        inputValidator.validateAndError(`createViewport`, branding.logo, 'string', false);
    inputValidator.validateAndError(`createViewport`, branding.backgroundColor, 'string', false);
    inputValidator.validateAndError(`createViewport`, branding.busyModeSpinner, 'string', false);
    inputValidator.validateAndError(`createViewport`, branding.busyModeDisplay, 'enum', false, Object.values(viewer_rendering_engine_rendering_engine_1.BUSY_MODE_DISPLAY));
    inputValidator.validateAndError(`createViewport`, branding.spinnerPositioning, 'enum', false, Object.values(viewer_rendering_engine_rendering_engine_1.SPINNER_POSITIONING));
    prop.sessionSettingsMode = prop.sessionSettingsMode !== undefined ? prop.sessionSettingsMode : viewer_rendering_engine_rendering_engine_1.SESSION_SETTINGS_MODE.FIRST;
    if (prop.sessionSettingsMode === viewer_rendering_engine_rendering_engine_1.SESSION_SETTINGS_MODE.MANUAL && !prop.sessionSettingsId)
        throw new viewer_shared_services_1.ShapeDiverViewerValidationError(`createViewport: Input could not be validated. sessionSettingsId has to point to a valid and created session when using SESSION_SETTINGS_MODE.MANUAL`, prop.sessionSettingsId, 'string');
    const renderingEngine = yield creationControlCenter.createRenderingEngineThreeJs(prop);
    exports.viewports[renderingEngine.id] = new ViewportApi_1.ViewportApi(renderingEngine);
    return exports.viewports[renderingEngine.id];
});
exports.createViewport = createViewport;
//# sourceMappingURL=main.js.map