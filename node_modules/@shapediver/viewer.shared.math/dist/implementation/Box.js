"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Box = void 0;
const gl_matrix_1 = require("gl-matrix");
const __1 = require("..");
class Box {
    // #endregion Properties (2)
    // #region Constructors (1)
    constructor(_min = gl_matrix_1.vec3.fromValues(Infinity, Infinity, Infinity), _max = gl_matrix_1.vec3.fromValues(-Infinity, -Infinity, -Infinity)) {
        this._min = _min;
        this._max = _max;
        // #region Properties (2)
        this._boundingSphere = new __1.Sphere();
        this._boundingSphereState = {
            min: gl_matrix_1.vec3.create(), max: gl_matrix_1.vec3.create()
        };
    }
    // #endregion Constructors (1)
    // #region Public Accessors (5)
    intersect(origin, direction) {
        let tmin, tmax, txmin, txmax, tymin, tymax, tzmin, tzmax;
        const invdirx = 1 / direction[0], invdiry = 1 / direction[1], invdirz = 1 / direction[2];
        txmin = invdirx >= 0 ? (this.min[0] - origin[0]) * invdirx : (this.max[0] - origin[0]) * invdirx;
        txmax = invdirx >= 0 ? (this.max[0] - origin[0]) * invdirx : (this.min[0] - origin[0]) * invdirx;
        tmin = txmin;
        tmax = txmax;
        tymin = invdiry >= 0 ? (this.min[1] - origin[1]) * invdiry : (this.max[1] - origin[1]) * invdiry;
        tymax = invdiry >= 0 ? (this.max[1] - origin[1]) * invdiry : (this.min[1] - origin[1]) * invdiry;
        if ((tmin > tymax) || (tymin > tmax))
            return null;
        // These lines also handle the case where tmin or tmax is NaN
        // (result of 0 * Infinity). x !== x returns true if x is NaN
        if (tymin > tmin || tmin !== tmin)
            tmin = tymin;
        if (tymax < tmax || tmax !== tmax)
            tmax = tymax;
        tzmin = invdirz >= 0 ? (this.min[2] - origin[2]) * invdirz : (this.max[2] - origin[2]) * invdirz;
        tzmax = invdirz >= 0 ? (this.max[2] - origin[2]) * invdirz : (this.min[2] - origin[2]) * invdirz;
        if ((tmin > tzmax) || (tzmin > tmax))
            return null;
        if (tzmin > tmin || tmin !== tmin)
            tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax)
            tmax = tzmax;
        //return point closest to the ray (positive side)
        if (tmax < 0)
            return null;
        return tmin >= 0 ? tmin : tmax;
    }
    ;
    intersects(origin, direction) {
        return this.intersect(origin, direction) === null ? false : true;
    }
    ;
    get boundingSphere() {
        if (!(this._boundingSphereState.min[0] === this.min[0] && this._boundingSphereState.min[1] === this.min[1] && this._boundingSphereState.min[2] === this.min[2] &&
            this._boundingSphereState.max[0] === this.max[0] && this._boundingSphereState.max[1] === this.max[1] && this._boundingSphereState.max[2] === this.max[2])) {
            this._boundingSphere.setFromBox(this);
            this._boundingSphereState = {
                min: gl_matrix_1.vec3.clone(this.min),
                max: gl_matrix_1.vec3.clone(this.max)
            };
        }
        return this._boundingSphere;
    }
    get max() {
        return this._max;
    }
    set max(value) {
        this._max = value;
    }
    get min() {
        return this._min;
    }
    set min(value) {
        this._min = value;
    }
    // #endregion Public Accessors (5)
    // #region Public Methods (5)
    applyMatrix(matrix) {
        const points = [];
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.min[0], this.min[1], this.min[2]), matrix));
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.min[0], this.min[1], this.max[2]), matrix));
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.min[0], this.max[1], this.min[2]), matrix));
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.min[0], this.max[1], this.max[2]), matrix));
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.max[0], this.min[1], this.min[2]), matrix));
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.max[0], this.min[1], this.max[2]), matrix));
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.max[0], this.max[1], this.min[2]), matrix));
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.max[0], this.max[1], this.max[2]), matrix));
        this.min = gl_matrix_1.vec3.fromValues(Infinity, Infinity, Infinity);
        this.max = gl_matrix_1.vec3.fromValues(-Infinity, -Infinity, -Infinity);
        for (let i = 0, il = points.length; i < il; i++) {
            this.min = gl_matrix_1.vec3.fromValues(Math.min(this.min[0], points[i][0]), Math.min(this.min[1], points[i][1]), Math.min(this.min[2], points[i][2]));
            this.max = gl_matrix_1.vec3.fromValues(Math.max(this.max[0], points[i][0]), Math.max(this.max[1], points[i][1]), Math.max(this.max[2], points[i][2]));
        }
        return this;
    }
    clone() {
        return new Box(gl_matrix_1.vec3.clone(this.min), gl_matrix_1.vec3.clone(this.max));
    }
    containsPoint(point) {
        return point[0] < this.min[0] || point[0] > this.max[0] ||
            point[1] < this.min[1] || point[1] > this.max[1] ||
            point[2] < this.min[2] || point[2] > this.max[2] ? false : true;
    }
    clampPoint(point) {
        point[0] = Math.max(this.min[0], Math.min(this.max[0], point[0]));
        point[1] = Math.max(this.min[1], Math.min(this.max[1], point[1]));
        point[2] = Math.max(this.min[2], Math.min(this.max[2], point[2]));
        return point;
    }
    setFromAttributeArray(array, stride, bytes, matrix = gl_matrix_1.mat4.create()) {
        let transformedArray = [];
        const length = (Math.floor(array.length / 3) * 3);
        const byteStride = (stride && stride !== bytes) ? +stride : 3;
        for (let i = 0; i < length; i += byteStride) {
            let point = gl_matrix_1.vec4.transformMat4(gl_matrix_1.vec4.create(), gl_matrix_1.vec4.fromValues(array[i], array[i + 1], array[i + 2], 1), matrix);
            transformedArray.push([point[0] / point[3], point[1] / point[3], point[2] / point[3]]);
        }
        let x_coords = transformedArray.map(p => p[0]);
        let y_coords = transformedArray.map(p => p[1]);
        let z_coords = transformedArray.map(p => p[2]);
        this.min = gl_matrix_1.vec3.fromValues(Math.min(...x_coords), Math.min(...y_coords), Math.min(...z_coords));
        this.max = gl_matrix_1.vec3.fromValues(Math.max(...x_coords), Math.max(...y_coords), Math.max(...z_coords));
        return this;
    }
    union(box) {
        if (box.min[0] < this.min[0])
            this.min[0] = box.min[0];
        if (box.min[1] < this.min[1])
            this.min[1] = box.min[1];
        if (box.min[2] < this.min[2])
            this.min[2] = box.min[2];
        if (box.max[0] > this.max[0])
            this.max[0] = box.max[0];
        if (box.max[1] > this.max[1])
            this.max[1] = box.max[1];
        if (box.max[2] > this.max[2])
            this.max[2] = box.max[2];
        return this;
    }
    isEmpty() {
        return this.min[0] === Infinity && this.min[1] === Infinity && this.min[2] === Infinity &&
            this.max[0] === -Infinity && this.max[1] === -Infinity && this.max[2] === -Infinity;
    }
    reset() {
        gl_matrix_1.vec3.zero(this._boundingSphere.center);
        this._boundingSphere.radius = 0;
        gl_matrix_1.vec3.zero(this._boundingSphereState.min);
        gl_matrix_1.vec3.zero(this._boundingSphereState.max);
        gl_matrix_1.vec3.set(this._min, Infinity, Infinity, Infinity);
        gl_matrix_1.vec3.set(this._max, -Infinity, -Infinity, -Infinity);
    }
}
exports.Box = Box;
//# sourceMappingURL=Box.js.map