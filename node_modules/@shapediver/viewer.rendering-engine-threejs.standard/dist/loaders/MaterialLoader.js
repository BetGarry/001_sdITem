"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MaterialLoader = exports.MATERIAL_TYPE = void 0;
const THREE = __importStar(require("three"));
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const PCSS_1 = require("../shaders/PCSS");
const SpecularGlossinessMaterial_1 = require("../materials/SpecularGlossinessMaterial");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const EnvironmentMapLoader_1 = require("./EnvironmentMapLoader");
const GemMaterial_1 = require("../materials/GemMaterial");
const SDColor_1 = require("../objects/SDColor");
var MATERIAL_TYPE;
(function (MATERIAL_TYPE) {
    MATERIAL_TYPE["POINT"] = "point";
    MATERIAL_TYPE["LINE"] = "line";
    MATERIAL_TYPE["MESH"] = "mesh";
})(MATERIAL_TYPE = exports.MATERIAL_TYPE || (exports.MATERIAL_TYPE = {}));
class MaterialLoader {
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (8)
        this._converter = viewer_shared_services_1.Converter.instance;
        this._defaultColor = '#199b9b';
        this._logger = viewer_shared_services_1.Logger.instance;
        this._materialCache = {};
        this._blending = 0.0;
        this._envMap = null;
        this._height = 1020;
        this._lightSizeUV = 0.025;
        this._pointSize = 1.0;
        this._textureEncoding = THREE.sRGBEncoding;
        this._maxMapCount = 0;
        this._envMapType = EnvironmentMapLoader_1.ENVIRONMENT_MAP_TYPE.NULL;
        let shader = THREE.ShaderChunk.shadowmap_pars_fragment;
        if (!shader.includes('PCSS implementation')) {
            shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP' + PCSS_1.main);
            shader = shader.replace(shader.substr(shader.indexOf('#if defined( SHADOWMAP_TYPE_PCF )'), shader.indexOf('#elif defined( SHADOWMAP_TYPE_PCF_SOFT )') - shader.indexOf('#if defined( SHADOWMAP_TYPE_PCF )')), '#if defined( SHADOWMAP_TYPE_PCF )\n' + PCSS_1.entry);
        }
        THREE.ShaderChunk.shadowmap_pars_fragment = shader;
        // console.log(THREE.ShaderChunk.envmap_fragment.includes(`vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );`))
        THREE.ShaderChunk.envmap_fragment = THREE.ShaderChunk.envmap_fragment.replace(`vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );`, `
            #ifdef ENVMAP_TYPE_LDR
                vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
            #else
                vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.zy ) );
            #endif
            `);
        // console.log(THREE.ShaderChunk.backgroundCube_frag.includes(`vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );`))
        THREE.ShaderChunk.backgroundCube_frag = THREE.ShaderChunk.backgroundCube_frag.replace(`vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );`, `
            #ifdef ENVMAP_TYPE_LDR
                vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
            #else
                vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.zy ) );
            #endif`);
        // console.log(THREE.ShaderChunk.cube_uv_reflection_fragment.includes(`vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );`))
        THREE.ShaderChunk.cube_uv_reflection_fragment = THREE.ShaderChunk.cube_uv_reflection_fragment.replace(`vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );`, `
            #ifdef ENVMAP_TYPE_LDR
                vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );            
            #else
                vec3 color0 = bilinearCubeUV( envMap, sampleDir.xzy, mipInt );            
            #endif`);
        // console.log(THREE.ShaderChunk.cube_uv_reflection_fragment.includes(`vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );`))
        THREE.ShaderChunk.cube_uv_reflection_fragment = THREE.ShaderChunk.cube_uv_reflection_fragment.replace(`vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );`, `
            #ifdef ENVMAP_TYPE_LDR
                vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );            
            #else
                vec3 color1 = bilinearCubeUV( envMap, sampleDir.xzy, mipInt + 1.0 );        
            #endif`);
        if (!THREE.ShaderChunk.lights_fragment_maps.includes('vec3 reflectVec')) {
            var index = THREE.ShaderChunk.lights_fragment_maps.lastIndexOf('#endif');
            THREE.ShaderChunk.lights_fragment_maps = THREE.ShaderChunk.lights_fragment_maps.substring(0, index) +
                `#else
                #ifdef ENVMAP_TYPE_NONE
                    vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );
                    reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
                    radiance += (vec3((reflectVec.z + 1.0) / 2.0) + 0.5) / 1.5;
                #endif
            #endif
            ` + THREE.ShaderChunk.lights_fragment_maps.substring(index + '#endif'.length);
        }
    }
    // #endregion Properties (8)
    // #region Constructors (1)
    cacheSize() {
        return Object.entries(this._materialCache).length;
    }
    // #endregion Constructors (1)
    // #region Public Methods (7)
    assignEnvironmentMap(e, type) {
        this._envMap = e;
        this._envMapType = type;
        for (let m in this._materialCache) {
            if ((this._materialCache[m].material instanceof THREE.MeshPhysicalMaterial || this._materialCache[m].material instanceof THREE.MeshStandardMaterial || this._materialCache[m].material instanceof THREE.MeshBasicMaterial)) {
                const material = this._materialCache[m].material;
                if (this._materialCache[m].materialData &&
                    (this._materialCache[m].materialData instanceof viewer_shared_types_1.MaterialStandardData ||
                        this._materialCache[m].materialData instanceof viewer_shared_types_1.MaterialGemData ||
                        this._materialCache[m].materialData instanceof viewer_shared_types_1.MaterialSpecularGlossinessData ||
                        this._materialCache[m].materialData instanceof viewer_shared_types_1.MaterialUnlitData) &&
                    this._materialCache[m].materialData.envMap !== undefined)
                    continue;
                if (this._materialCache[m].materialData instanceof viewer_shared_types_1.MaterialUnlitData && this._renderingEngine.environmentMapForUnlitMaterials === false)
                    return;
                material.envMap = e;
                material.needsUpdate = true;
                for (let d in material.defines) {
                    if (d.startsWith('ENVMAP_TYPE_'))
                        delete material.defines[d];
                }
                if (material.defines)
                    material.defines['ENVMAP_TYPE_' + this._envMapType.toUpperCase()] = '';
            }
        }
    }
    assignEnvironmentMapForUnlitMaterials(toggle) {
        for (let m in this._materialCache) {
            if (this._materialCache[m].material instanceof THREE.MeshBasicMaterial) {
                const material = this._materialCache[m].material;
                if (this._materialCache[m].materialData &&
                    this._materialCache[m].materialData instanceof viewer_shared_types_1.MaterialUnlitData &&
                    this._materialCache[m].materialData.envMap !== undefined)
                    continue;
                if (toggle) {
                    material.envMap = this._envMap;
                    material.needsUpdate = true;
                    for (let d in material.defines) {
                        if (d.startsWith('ENVMAP_TYPE_'))
                            delete material.defines[d];
                    }
                    if (material.defines)
                        material.defines['ENVMAP_TYPE_' + this._envMapType.toUpperCase()] = '';
                }
                else {
                    material.envMap = null;
                    material.needsUpdate = true;
                }
            }
        }
    }
    assignPointSize(p) {
        const height = this._renderingEngine.renderer ? this._renderingEngine.renderer.getSize(new THREE.Vector2()).y : 1080;
        if (height === this._height && p * (this._height / 1080) === this._pointSize)
            return;
        this._height = height;
        this._pointSize = p * (this._height / 1080);
        for (let m in this._materialCache) {
            if (this._materialCache[m].material instanceof THREE.PointsMaterial) {
                this._materialCache[m].material.size = this._pointSize;
                this._materialCache[m].material.needsUpdate = true;
            }
        }
    }
    assignTextureEncoding() {
        for (let m in this._materialCache) {
            if (this._materialCache[m].material instanceof THREE.MeshPhysicalMaterial || this._materialCache[m].material instanceof THREE.MeshStandardMaterial) {
                const material = this._materialCache[m].material;
                if (material.emissiveMap) {
                    material.emissiveMap.encoding = this._textureEncoding;
                    material.emissiveMap.needsUpdate = true;
                }
                if (material.map) {
                    material.map.encoding = this._textureEncoding;
                    material.map.needsUpdate = true;
                }
                material.needsUpdate = true;
            }
        }
    }
    assignColorCorrection(value) {
        const convertColor = (c, toggle) => {
            if (!c)
                return;
            if (c instanceof SDColor_1.SDColor) {
                c.colorCorrection(toggle);
                return c;
            }
            else {
                const sdColor = this._renderingEngine.colorCache.find(color => color.equals(c));
                if (sdColor) {
                    sdColor.colorCorrection(toggle);
                    return sdColor;
                }
                else {
                    // some colors may not have been set by us, but have been set automatically
                    // in this case we expect the color to be linear either way and therefore omit a color correction
                    return c;
                }
            }
        };
        for (let m in this._materialCache) {
            const material = this._materialCache[m].material;
            material.color = convertColor(material.color, value);
            material.specular = convertColor(material.specular, value);
            material.emissive = convertColor(material.emissive, value);
            material.colorTransferBegin = convertColor(material.colorTransferBegin, value);
            material.colorTransferEnd = convertColor(material.colorTransferEnd, value);
            material.attenuationColor = convertColor(material.attenuationColor, value);
            material.sheencolor = convertColor(material.sheencolor, value);
            material.specularColor = convertColor(material.specularColor, value);
            material.needsUpdate = true;
        }
    }
    emptyMaterialCache() {
        this._materialCache = {};
    }
    removeFromMaterialCache(id) {
        for (let m in this._materialCache) {
            if (m.startsWith(id)) {
                delete this._materialCache[m];
            }
        }
    }
    init() { }
    getMaterialProperties(materialData, type, materialSettings) {
        const generalProperties = {};
        let mapCount = 0;
        // if no MaterialStandardData is provided, we return our default
        if (!materialData) {
            generalProperties.color = this._renderingEngine.createThreeJsColor(this._defaultColor);
            if (materialSettings !== undefined && materialSettings.useVertexColors)
                generalProperties.color = this._renderingEngine.createThreeJsColor('#d3d3d3');
            generalProperties.side = THREE.DoubleSide;
            if (!(type === MATERIAL_TYPE.POINT || type === MATERIAL_TYPE.LINE))
                generalProperties.envMap = this._envMap;
            return { properties: generalProperties, mapCount };
        }
        /**
         * We know evaluate properties that can be applied to all materials
         */
        generalProperties.alphaTest = materialData.alphaCutoff;
        if (materialData.opacity !== undefined) {
            generalProperties.opacity = materialData.opacity;
            generalProperties.transparent = generalProperties.opacity < 1;
        }
        if (materialData.alphaMode === viewer_shared_types_1.MATERIAL_ALPHA.BLEND) {
            generalProperties.transparent = true;
            generalProperties.depthWrite = false;
        }
        else if (!generalProperties.transparent) {
            generalProperties.transparent = false;
        }
        if (materialData.color !== undefined)
            generalProperties.color = this._renderingEngine.createThreeJsColor(materialData.color);
        if (materialData.color === undefined && materialData.map !== undefined && materialData.map.color !== undefined)
            generalProperties.color = this._renderingEngine.createThreeJsColor(materialData.map.color);
        if (materialData.color === undefined && materialData.map !== undefined && materialData.map.color === undefined && !(materialSettings !== undefined && materialSettings.useVertexColors))
            generalProperties.color = this._renderingEngine.createThreeJsColor(this._defaultColor);
        if ((materialSettings !== undefined && materialSettings.useVertexColors) && (materialData.color === this._defaultColor || materialData.color === this._defaultColor + 'ff' || materialData.color === undefined))
            generalProperties.color = this._renderingEngine.createThreeJsColor('#d3d3d3');
        if (materialData.side !== undefined)
            generalProperties.side = materialData.side === viewer_shared_types_1.MATERIAL_SIDE.BACK ? THREE.BackSide : materialData.side === viewer_shared_types_1.MATERIAL_SIDE.FRONT ? THREE.FrontSide : THREE.DoubleSide;
        /**
         *
         * First exit, lines ans points
         *
         */
        if (type === MATERIAL_TYPE.POINT) {
            generalProperties.size = this._pointSize;
            return { properties: generalProperties, mapCount };
        }
        else if (type === MATERIAL_TYPE.LINE) {
            return { properties: generalProperties, mapCount };
        }
        /**
         *
         * Second exit, the shadow material
         *
         */
        if (materialData instanceof viewer_shared_types_1.MaterialShadowData)
            return { properties: generalProperties, mapCount };
        /**
         * We know evaluate properties that can be applied to basic mesh materials (and the ones extending from them)
         */
        const basicProperties = generalProperties;
        if (materialData.alphaMap !== undefined) {
            basicProperties.alphaMap = this.createTexture(materialData.alphaMap);
            basicProperties.transparent = true;
            basicProperties.depthWrite = false;
            mapCount++;
        }
        if (materialData.aoMap !== undefined) {
            basicProperties.aoMap = this.createTexture(materialData.aoMap);
            mapCount++;
        }
        if (materialData.aoMapIntensity !== undefined) {
            basicProperties.aoMapIntensity = materialData.aoMapIntensity;
        }
        if (materialData.map !== undefined) {
            basicProperties.map = this.createTexture(materialData.map);
            basicProperties.map.encoding = this._textureEncoding;
            mapCount++;
        }
        /**
         *
         * Third exit, the unlit material
         *
         */
        if (materialData instanceof viewer_shared_types_1.MaterialUnlitData)
            return { properties: basicProperties, mapCount };
        /**
         * We know evaluate properties that can be applied to MeshPhysicalMaterials, SpecularGlossinessMaterials and GemMaterialParameters
         */
        const standardProperties = basicProperties;
        if (materialData.shading !== undefined)
            standardProperties.flatShading = materialData.shading !== 'smooth';
        if (materialData.bumpMap !== undefined) {
            standardProperties.bumpMap = this.createTexture(materialData.bumpMap);
            mapCount++;
        }
        standardProperties.bumpScale = materialData.bumpScale;
        if (materialData.emissiveness !== undefined)
            standardProperties.emissive = this._renderingEngine.createThreeJsColor(materialData.emissiveness);
        if (materialData.emissiveMap !== undefined) {
            standardProperties.emissiveMap = this.createTexture(materialData.emissiveMap);
            standardProperties.emissiveMap.encoding = this._textureEncoding;
            mapCount++;
        }
        standardProperties.envMap = this._envMap;
        if (materialData.normalMap !== undefined) {
            standardProperties.normalMap = this.createTexture(materialData.normalMap);
            mapCount++;
        }
        if (materialData.normalScale !== undefined)
            standardProperties.normalScale = new THREE.Vector2(materialData.normalScale, -materialData.normalScale);
        /**
         *
         * Fourth exit, the specular-glossiness material
         *
         */
        if (materialData instanceof viewer_shared_types_1.MaterialSpecularGlossinessData) {
            const specularGlossinessProperties = standardProperties;
            specularGlossinessProperties.specular = this._renderingEngine.createThreeJsColor(materialData.specular);
            specularGlossinessProperties.glossiness = materialData.glossiness;
            if (materialData.specularGlossinessMap !== undefined) {
                specularGlossinessProperties.specularMap = this.createTexture(materialData.specularGlossinessMap);
                specularGlossinessProperties.specularMap.encoding = THREE.sRGBEncoding;
                specularGlossinessProperties.glossinessMap = specularGlossinessProperties.specularMap;
                mapCount++;
            }
            else {
                if (materialData.specularMap !== undefined) {
                    specularGlossinessProperties.specularMap = this.createTexture(materialData.specularMap);
                    specularGlossinessProperties.specularMap.encoding = THREE.sRGBEncoding;
                    mapCount++;
                }
                if (materialData.glossinessMap !== undefined) {
                    specularGlossinessProperties.glossinessMap = this.createTexture(materialData.glossinessMap);
                    mapCount++;
                }
            }
            return { properties: specularGlossinessProperties, mapCount };
        }
        /**
         *
         * Fourth exit, the gem material
         *
         */
        if (materialData instanceof viewer_shared_types_1.MaterialGemData) {
            const gemProperties = standardProperties;
            gemProperties.refractionIndex = materialData.refractionIndex;
            if (materialData.impurityMap !== undefined) {
                gemProperties.impurityMap = this.createTexture(materialData.impurityMap);
                mapCount++;
            }
            gemProperties.impurityScale = materialData.impurityScale;
            if (materialData.colorTransferBegin !== undefined) {
                gemProperties.colorTransferBegin = this._renderingEngine.createThreeJsColor(materialData.colorTransferBegin);
            }
            if (materialData.colorTransferEnd !== undefined) {
                gemProperties.colorTransferEnd = this._renderingEngine.createThreeJsColor(materialData.colorTransferEnd);
            }
            gemProperties.center = new THREE.Vector3(materialData.center[0], materialData.center[1], materialData.center[2]);
            gemProperties.tracingDepth = materialData.tracingDepth;
            gemProperties.radius = materialData.radius;
            gemProperties.sphericalNormalMap = materialData.sphericalNormalMap;
            gemProperties.gamma = materialData.gamma;
            gemProperties.contrast = materialData.contrast;
            gemProperties.brightness = materialData.brightness;
            gemProperties.dispersion = materialData.dispersion;
            gemProperties.tracingOpacity = materialData.tracingOpacity;
            gemProperties.roughness = 0;
            gemProperties.metalness = 1;
            gemProperties.transparent = true;
            gemProperties.opacity = 1.0;
            gemProperties.side = THREE.FrontSide;
            return { properties: gemProperties, mapCount };
        }
        /**
         *
         * the final exit, the MeshPhysicalMaterial
         *
         */
        if (materialData instanceof viewer_shared_types_1.MaterialStandardData) {
            const meshPhysicalProperties = standardProperties;
            meshPhysicalProperties.clearcoat = materialData.clearcoat;
            if (materialData.clearcoatMap !== undefined) {
                meshPhysicalProperties.clearcoatMap = this.createTexture(materialData.clearcoatMap);
                mapCount++;
            }
            if (materialData.clearcoatNormalMap !== undefined) {
                meshPhysicalProperties.clearcoatNormalMap = this.createTexture(materialData.clearcoatNormalMap);
                mapCount++;
            }
            meshPhysicalProperties.clearcoatRoughness = materialData.clearcoatRoughness;
            if (materialData.clearcoatRoughnessMap !== undefined) {
                meshPhysicalProperties.clearcoatRoughnessMap = this.createTexture(materialData.clearcoatRoughnessMap);
                mapCount++;
            }
            if (materialData.displacementMap !== undefined) {
                meshPhysicalProperties.displacementMap = this.createTexture(materialData.displacementMap);
                mapCount++;
            }
            meshPhysicalProperties.displacementScale = materialData.displacementScale;
            meshPhysicalProperties.displacementBias = materialData.displacementBias;
            meshPhysicalProperties.ior = materialData.ior;
            meshPhysicalProperties.transmission = materialData.transmission;
            if (materialData.transmissionMap !== undefined) {
                meshPhysicalProperties.transmissionMap = this.createTexture(materialData.transmissionMap);
                mapCount++;
            }
            meshPhysicalProperties.thickness = materialData.thickness;
            if (materialData.thicknessMap !== undefined) {
                meshPhysicalProperties.thicknessMap = this.createTexture(materialData.thicknessMap);
                mapCount++;
            }
            meshPhysicalProperties.attenuationDistance = materialData.attenuationDistance;
            meshPhysicalProperties.attenuationColor = this._renderingEngine.createThreeJsColor(materialData.attenuationColor);
            meshPhysicalProperties.sheen = materialData.sheen;
            meshPhysicalProperties.sheenColor = this._renderingEngine.createThreeJsColor(materialData.sheenColor);
            meshPhysicalProperties.sheenRoughness = materialData.sheenRoughness;
            if (materialData.sheenColorMap !== undefined) {
                meshPhysicalProperties.sheenColorMap = this.createTexture(materialData.sheenColorMap);
                mapCount++;
            }
            if (materialData.sheenRoughnessMap !== undefined) {
                meshPhysicalProperties.sheenRoughnessMap = this.createTexture(materialData.sheenRoughnessMap);
                mapCount++;
            }
            meshPhysicalProperties.specularIntensity = materialData.specularIntensity;
            if (materialData.specularIntensityMap !== undefined) {
                meshPhysicalProperties.specularIntensityMap = this.createTexture(materialData.specularIntensityMap);
                mapCount++;
            }
            meshPhysicalProperties.specularColor = this._renderingEngine.createThreeJsColor(materialData.specularColor);
            if (materialData.specularColorMap !== undefined) {
                meshPhysicalProperties.specularColorMap = this.createTexture(materialData.specularColorMap);
                mapCount++;
            }
            meshPhysicalProperties.metalness = materialData.metalness;
            meshPhysicalProperties.roughness = materialData.roughness;
            if (materialData.metalnessRoughnessMap !== undefined) {
                meshPhysicalProperties.metalnessMap = this.createTexture(materialData.metalnessRoughnessMap);
                meshPhysicalProperties.roughnessMap = meshPhysicalProperties.metalnessMap;
                mapCount++;
            }
            else {
                if (materialData.metalnessMap !== undefined) {
                    meshPhysicalProperties.metalnessMap = this.createTexture(materialData.metalnessMap);
                    mapCount++;
                }
                if (materialData.roughnessMap !== undefined) {
                    meshPhysicalProperties.roughnessMap = this.createTexture(materialData.roughnessMap);
                    mapCount++;
                }
            }
            return { properties: meshPhysicalProperties, mapCount };
        }
        // we should never get here
        throw new viewer_shared_services_1.ShapeDiverViewerDataProcessingError(`MaterialLoader.getMaterialProperties: No proper material properties were found.`);
    }
    createMaterial(type, incomingData, materialData, materialSettings) {
        let { properties, mapCount } = this.getMaterialProperties(materialData, type, materialSettings);
        this.maxMapCount = Math.max(this.maxMapCount, mapCount);
        let material;
        if (type === MATERIAL_TYPE.POINT) {
            material = new THREE.PointsMaterial(Object.assign(properties, { size: this._pointSize }));
        }
        else if (type === MATERIAL_TYPE.LINE) {
            material = new THREE.LineBasicMaterial(properties);
        }
        else {
            if (materialData instanceof viewer_shared_types_1.MaterialUnlitData) {
                material = new THREE.MeshBasicMaterial(properties);
            }
            else {
                if (materialData instanceof viewer_shared_types_1.MaterialShadowData) {
                    material = new THREE.ShadowMaterial({ opacity: properties.opacity, color: properties.color });
                }
                else if (materialData instanceof viewer_shared_types_1.MaterialSpecularGlossinessData) {
                    material = new SpecularGlossinessMaterial_1.SpecularGlossinessMaterial(properties);
                }
                else if (materialData instanceof viewer_shared_types_1.MaterialGemData) {
                    material = new GemMaterial_1.GemMaterial(properties);
                }
                else {
                    material = new THREE.MeshPhysicalMaterial(properties);
                }
                const before = material.onBeforeCompile;
                material.onBeforeCompile = (shader, renderer) => {
                    before(shader, renderer);
                    shader.uniforms.lightSizeUV = { value: this._lightSizeUV };
                    shader.uniforms.blending = { value: this._blending };
                    material.userData.shader = shader;
                };
                if (material instanceof SpecularGlossinessMaterial_1.SpecularGlossinessMaterial || material instanceof THREE.MeshPhysicalMaterial) {
                    material.defines['ENVMAP_TYPE_' + this._envMapType.toUpperCase()] = '';
                    if (materialSettings && materialSettings.useVertexTangents)
                        material.normalScale.y *= -1;
                    if (materialSettings && materialSettings.useVertexTangents && material instanceof THREE.MeshPhysicalMaterial)
                        material.clearcoatNormalScale.y *= -1;
                    if (materialSettings && materialSettings.useFlatShading)
                        material.flatShading = true;
                }
            }
        }
        if (materialSettings && materialSettings.useVertexColors)
            material.vertexColors = true;
        if (materialData instanceof viewer_shared_types_1.MaterialStandardData || materialData instanceof viewer_shared_types_1.MaterialGemData || materialData instanceof viewer_shared_types_1.MaterialSpecularGlossinessData || materialData instanceof viewer_shared_types_1.MaterialUnlitData) {
            if (materialData.envMap !== undefined) {
                const envMapInput = materialData.envMap;
                if (envMapInput !== undefined) {
                    this._renderingEngine.environmentMapLoader.loadEnvMap(envMapInput).then(envMapResult => {
                        if (material instanceof THREE.MeshBasicMaterial && this._renderingEngine.environmentMapForUnlitMaterials === false)
                            return;
                        material.envMap = envMapResult.map;
                        const envMapType = material.envMap instanceof THREE.CubeTexture ? EnvironmentMapLoader_1.ENVIRONMENT_MAP_TYPE.LDR : EnvironmentMapLoader_1.ENVIRONMENT_MAP_TYPE.HDR;
                        for (let d in material.defines) {
                            if (d.startsWith('ENVMAP_TYPE_'))
                                delete material.defines[d];
                        }
                        if (material.defines)
                            material.defines['ENVMAP_TYPE_' + envMapType.toUpperCase()] = '';
                        material.needsUpdate = true;
                    });
                }
            }
        }
        if (materialData)
            materialData.threeJsObject[this._renderingEngine.id] = material;
        material.needsUpdate = true;
        material.userData = {
            SDid: incomingData.id,
            SDversion: incomingData.version
        };
        return material;
    }
    /**
     * Create a material object with the provided material data.
     *
     * @param material the material data
     * @returns the material object
     */
    load(incomingData, materialSettings) {
        let materialData = null;
        if (!(incomingData instanceof viewer_shared_types_1.GeometryData))
            materialData = incomingData;
        // evaluate which type of material properties we are constructing
        let type;
        if (materialSettings && materialSettings.mode === 0) {
            type = MATERIAL_TYPE.POINT;
        }
        else if (materialSettings && (materialSettings.mode === 1 || materialSettings.mode === 2 || materialSettings.mode === 3)) {
            type = MATERIAL_TYPE.LINE;
        }
        else {
            type = MATERIAL_TYPE.MESH;
        }
        if (!materialData) {
            // evaluate which type of material properties we are constructing
            if (materialSettings && materialSettings.mode === 0) {
                if (this._defaultPointsMaterial)
                    return this._defaultPointsMaterial;
            }
            else if (materialSettings && (materialSettings.mode === 1 || materialSettings.mode === 2 || materialSettings.mode === 3)) {
                if (this._defaultLineMaterial)
                    return this._defaultLineMaterial;
            }
            else {
                if (this._defaultMaterial)
                    return this._defaultMaterial;
            }
            const material = this.createMaterial(type, incomingData, materialData, materialSettings);
            if (type === MATERIAL_TYPE.POINT) {
                this._defaultPointsMaterial = material;
            }
            else if (type === MATERIAL_TYPE.LINE) {
                this._defaultLineMaterial = material;
            }
            else {
                this._defaultMaterial = material;
            }
            this._materialCache[type + '_' + type] = {
                material,
                materialData
            };
            return material;
        }
        if (this._materialCache[incomingData.id + '_' + incomingData.version + '_' + type])
            return this._materialCache[incomingData.id + '_' + incomingData.version + '_' + type].material;
        const material = this.createMaterial(type, incomingData, materialData, materialSettings);
        if (this._materialCache[incomingData.id + '_' + incomingData.version + '_' + type]) {
            this._materialCache[incomingData.id + '_' + incomingData.version + '_' + type].material.copy(material);
            return this._materialCache[incomingData.id + '_' + incomingData.version + '_' + type].material;
        }
        this._materialCache[incomingData.id + '_' + incomingData.version + '_' + type] = {
            material,
            materialData
        };
        return material;
    }
    updateMaterials() {
        for (let m in this._materialCache)
            this._materialCache[m].material.needsUpdate = true;
    }
    updateSoftShadow(lightSizeUV, blending) {
        this._lightSizeUV = lightSizeUV;
        this._blending = blending;
        for (let m in this._materialCache) {
            if (this._materialCache[m].material.userData.shader) {
                this._materialCache[m].material.userData.shader.uniforms.lightSizeUV.value = lightSizeUV;
                this._materialCache[m].material.userData.shader.uniforms.blending.value = blending;
            }
        }
    }
    // #endregion Public Methods (7)
    // #region Private Methods (1)
    createTexture(map) {
        const texture = new THREE.Texture(map.image);
        texture.format = THREE.RGBAFormat;
        texture.minFilter = (() => {
            switch (map.minFilter) {
                case viewer_shared_types_1.TEXTURE_FILTERING.NEAREST:
                    return THREE.NearestFilter;
                case viewer_shared_types_1.TEXTURE_FILTERING.NEAREST_MIPMAP_NEAREST:
                    return THREE.NearestMipMapNearestFilter;
                case viewer_shared_types_1.TEXTURE_FILTERING.LINEAR_MIPMAP_NEAREST:
                    return THREE.LinearMipMapNearestFilter;
                case viewer_shared_types_1.TEXTURE_FILTERING.NEAREST_MIPMAP_LINEAR:
                    return THREE.NearestMipMapLinearFilter;
                case viewer_shared_types_1.TEXTURE_FILTERING.LINEAR:
                    return THREE.LinearFilter;
                case viewer_shared_types_1.TEXTURE_FILTERING.LINEAR_MIPMAP_LINEAR:
                default:
                    return THREE.LinearMipMapLinearFilter;
            }
        })();
        texture.magFilter = (() => {
            switch (map.magFilter) {
                case viewer_shared_types_1.TEXTURE_FILTERING.NEAREST:
                    return THREE.NearestFilter;
                case viewer_shared_types_1.TEXTURE_FILTERING.LINEAR:
                default:
                    return THREE.LinearFilter;
            }
        })();
        texture.wrapS = (() => {
            switch (map.wrapS) {
                case viewer_shared_types_1.TEXTURE_WRAPPING.CLAMP_TO_EDGE:
                    return THREE.ClampToEdgeWrapping;
                case viewer_shared_types_1.TEXTURE_WRAPPING.MIRRORED_REPEAT:
                    return THREE.MirroredRepeatWrapping;
                case viewer_shared_types_1.TEXTURE_WRAPPING.REPEAT:
                default:
                    return THREE.RepeatWrapping;
            }
        })();
        texture.wrapT = (() => {
            switch (map.wrapT) {
                case viewer_shared_types_1.TEXTURE_WRAPPING.CLAMP_TO_EDGE:
                    return THREE.ClampToEdgeWrapping;
                case viewer_shared_types_1.TEXTURE_WRAPPING.MIRRORED_REPEAT:
                    return THREE.MirroredRepeatWrapping;
                case viewer_shared_types_1.TEXTURE_WRAPPING.REPEAT:
                default:
                    return THREE.RepeatWrapping;
            }
        })();
        texture.center = new THREE.Vector2(map.center[0], map.center[1]);
        texture.offset = new THREE.Vector2(map.offset[0], map.offset[1]);
        texture.repeat = new THREE.Vector2(map.repeat[0], map.repeat[1]);
        texture.rotation = map.rotation;
        texture.flipY = map.flipY;
        texture.needsUpdate = true;
        return texture;
    }
    get maxMapCount() {
        return this._maxMapCount;
    }
    set maxMapCount(value) {
        this._maxMapCount = value;
    }
    get textureEncoding() {
        return this._textureEncoding;
    }
    set textureEncoding(value) {
        this._textureEncoding = value;
        this.assignTextureEncoding();
    }
}
exports.MaterialLoader = MaterialLoader;
//# sourceMappingURL=MaterialLoader.js.map