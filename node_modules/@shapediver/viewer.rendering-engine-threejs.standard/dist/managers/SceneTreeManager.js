"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SceneTreeManager = void 0;
const THREE = __importStar(require("three"));
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_math_1 = require("@shapediver/viewer.shared.math");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_rendering_engine_light_engine_1 = require("@shapediver/viewer.rendering-engine.light-engine");
const gl_matrix_1 = require("gl-matrix");
const viewer_rendering_engine_rendering_engine_1 = require("@shapediver/viewer.rendering-engine.rendering-engine");
const ThreejsData_1 = require("../types/ThreejsData");
const viewer_rendering_engine_camera_engine_1 = require("@shapediver/viewer.rendering-engine.camera-engine");
const SDData_1 = require("../objects/SDData");
const SDObject_1 = require("../objects/SDObject");
const SDBone_1 = require("../objects/SDBone");
class SceneTreeManager {
    // #endregion Properties (13)
    // #region Constructors (1)
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        // #region Properties (13)
        this._converter = viewer_shared_services_1.Converter.instance;
        this._eventEngine = viewer_shared_services_1.EventEngine.instance;
        this._inputValidator = viewer_shared_services_1.InputValidator.instance;
        this._logger = viewer_shared_services_1.Logger.instance;
        this._scene = new THREE.Scene();
        this._stateEngine = viewer_shared_services_1.StateEngine.instance;
        this._tree = viewer_shared_node_tree_1.Tree.instance;
        this._boundingBox = new viewer_shared_math_1.Box();
        this._boundingBoxSensitiveData = [];
        this._lastRendererType = viewer_rendering_engine_rendering_engine_1.RENDERER_TYPE.STANDARD;
        this._lastRootVersion = '';
        this._scene.background = new THREE.Color('#ffffff');
    }
    // #endregion Constructors (1)
    // #region Public Accessors (4)
    get boundingBox() {
        return this._boundingBox;
    }
    get lastRendererType() {
        return this._lastRendererType;
    }
    get lastRootVersion() {
        return this._lastRootVersion;
    }
    get scene() {
        return this._scene;
    }
    // #endregion Public Accessors (4)
    // #region Public Methods (6)
    init() { }
    isEmpty() {
        return ((this._boundingBox.min[0] === 0 && this._boundingBox.min[1] === 0 && this._boundingBox.min[2] === 0 &&
            this._boundingBox.max[0] === 0 && this._boundingBox.max[1] === 0 && this._boundingBox.max[2] === 0) || this._boundingBox.isEmpty());
    }
    /**
     * Convert the data of the scene graph node into the format of the implementation.
     *
     * @param data the data element
     * @param obj the corresponding type node
     */
    updateData(node, obj, data, filter, skeleton) {
        let dataChild = obj.children.find(oc => oc.SDid === data.id && oc.SDversion === data.version);
        let newChild = false;
        if (!dataChild) {
            newChild = true;
            dataChild = new SDData_1.SDData(data.id, data.version);
            obj.add(dataChild);
        }
        if (this._renderingEngine.type === viewer_rendering_engine_rendering_engine_1.RENDERER_TYPE.ATTRIBUTES)
            this.injectAttributeData(node, data);
        switch (true) {
            case data instanceof viewer_shared_types_1.GeometryData:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.GEOMETRY;
                if (filter.transformationOnly === false)
                    this._renderingEngine.geometryLoader.load(data, dataChild, newChild, skeleton);
                const bb = data.primitive.computeBoundingBox(node.worldMatrix);
                // adjust the general BB
                node.boundingBox.union(bb);
                // create the specific BB if it doesn't exist yet
                if (!node.boundingBoxViewport[this._renderingEngine.id])
                    node.boundingBoxViewport[this._renderingEngine.id] = new viewer_shared_math_1.Box();
                // adjust the specific BB
                node.boundingBoxViewport[this._renderingEngine.id].union(bb);
                break;
            case data instanceof ThreejsData_1.ThreejsData:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.THREEJS;
                dataChild.add(data.obj);
                const bbThree = new THREE.Box3().setFromObject(data.obj);
                // adjust the general BB
                node.boundingBox.union(new viewer_shared_math_1.Box(gl_matrix_1.vec3.fromValues(...bbThree.min.toArray()), gl_matrix_1.vec3.fromValues(...bbThree.max.toArray())));
                // create the specific BB if it doesn't exist yet
                if (!node.boundingBoxViewport[this._renderingEngine.id])
                    node.boundingBoxViewport[this._renderingEngine.id] = new viewer_shared_math_1.Box();
                // adjust the specific BB
                node.boundingBoxViewport[this._renderingEngine.id].union(new viewer_shared_math_1.Box(gl_matrix_1.vec3.fromValues(...bbThree.min.toArray()), gl_matrix_1.vec3.fromValues(...bbThree.max.toArray())));
                break;
            case data instanceof viewer_shared_types_1.AbstractMaterialData:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.MATERIAL;
                break;
            case data instanceof viewer_rendering_engine_light_engine_1.AbstractLight:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.LIGHT;
                if (filter.transformationOnly === false)
                    this._renderingEngine.lightLoader.load(data, dataChild);
                if (data instanceof viewer_rendering_engine_light_engine_1.DirectionalLight && data.useNodeData === false)
                    this._boundingBoxSensitiveData.push({ data: data, dataChild });
                break;
            case data instanceof viewer_rendering_engine_camera_engine_1.AbstractCamera:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.CAMERA;
                if (filter.transformationOnly === false)
                    this._renderingEngine.cameraManager.load(data, dataChild);
                break;
            case data instanceof viewer_shared_types_1.HTMLElementAnchorData:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.HTML_ELEMENT_ANCHOR;
                if (filter.transformationOnly === false)
                    this._renderingEngine.htmlElementAnchorLoader.load(node, data);
                break;
            case data instanceof viewer_shared_types_1.AnimationData:
                dataChild.SDtype = SDData_1.SD_DATA_TYPE.ANIMATION;
                break;
            default:
                // if there is no valid conversion here, call the convertData of the implementation
                break;
        }
    }
    updateMorphWeights(node = this._tree.root, obj = this._mainNode) {
        if (!node || !obj)
            return;
        for (let i = 0, len = node.data.length; i < len; i++) {
            if (node.data[i] instanceof viewer_shared_types_1.GeometryData) {
                const data = node.data[i];
                let dataChild = obj.children.find(oc => oc.SDid === data.id && oc.SDversion === data.version);
                if (dataChild)
                    dataChild.traverse(o => {
                        if (o instanceof THREE.Points ||
                            o instanceof THREE.LineSegments ||
                            o instanceof THREE.LineLoop ||
                            o instanceof THREE.Line ||
                            o instanceof THREE.Mesh)
                            o.morphTargetInfluences = data.morphWeights;
                    });
            }
        }
        for (let i = 0, len = node.children.length; i < len; i++) {
            const nodeChild = node.children[i];
            if (!nodeChild)
                continue;
            const objChild = obj.children.find(oc => oc.SDid === nodeChild.id);
            if (objChild)
                this.updateMorphWeights(nodeChild, objChild);
        }
    }
    /**
     * Update the current node via the scene graph node.
     * Convert the data if needed.
     *
     * @param node the scene graph node
     * @param obj the current type object
     */
    updateNode(node = this._tree.root, obj = this._mainNode, filter = { transformationOnly: false }, skeleton) {
        const convertedObject = obj;
        // reset the general bounding box of the current node
        // it will be recomputed in the following steps
        node.boundingBox.reset();
        // create the specific BB if it doesn't exist yet
        if (!node.boundingBoxViewport[this._renderingEngine.id])
            node.boundingBoxViewport[this._renderingEngine.id] = new viewer_shared_math_1.Box();
        // reset the specific bounding box of the current node
        // it will be recomputed in the following steps
        node.boundingBoxViewport[this._renderingEngine.id].reset();
        if (filter.transformationOnly === false) {
            // remove all data items that do not exist anymore
            const dataIds = node.data.map(d => d.id);
            const dataToRemove = convertedObject.children.filter(oc => oc instanceof SDData_1.SDData ? !(dataIds.includes(oc.SDid)) || !(node.data.find(d => d.id === oc.SDid).version === oc.SDversion) : false);
            dataToRemove.forEach(dTR => {
                this.removeData(dTR);
                convertedObject.remove(dTR);
            });
            // remove all child nodes in the transformed object that do not exist anymore
            // the filter goes also through the data items as they were already added
            const nodeIds = node.children.filter(d => !d.excludeViewports.includes(this._renderingEngine.id)).map(d => d.id);
            const childrenToRemove = convertedObject.children.filter(oc => oc instanceof SDObject_1.SDObject && !(oc instanceof SDData_1.SDData) ? !nodeIds.includes(oc.SDid) : false);
            childrenToRemove.forEach(cTR => {
                cTR.traverse((o) => {
                    if (o instanceof SDData_1.SDData)
                        this.removeData(o);
                });
                convertedObject.remove(cTR);
            });
        }
        // create the skeleton if the node is marked as the skin node (root node of the skeleton)
        if (node.skinNode === true) {
            const bones = [];
            for (let i = 0; i < node.bones.length; i++)
                bones.push(this.getBone(node.bones[i]));
            const boneInverses = [];
            for (let i = 0; i < node.boneInverses.length; i++)
                boneInverses.push(new THREE.Matrix4().fromArray(node.boneInverses[i]));
            skeleton = new THREE.Skeleton(bones, boneInverses);
        }
        // convert all data items of the current node
        // old versions will be replaced by new ones
        for (let i = 0, len = node.data.length; i < len; i++)
            this.updateData(node, convertedObject, node.data[i], filter, skeleton);
        // add new children and update the ones that have a different version
        for (let i = 0, len = node.children.length; i < len; i++) {
            const nodeChild = node.children[i];
            const objChild = convertedObject.children.find(oc => oc.SDid === nodeChild.id);
            if (!objChild) {
                const newChild = node.data.find(d => d instanceof viewer_shared_types_1.BoneData) ? new SDBone_1.SDBone(nodeChild.id, nodeChild.version) : new SDObject_1.SDObject(nodeChild.id, nodeChild.version);
                const oldChild = nodeChild.threeJsObject[this._renderingEngine.id];
                nodeChild.threeJsObject[this._renderingEngine.id] = newChild;
                if (nodeChild.updateCallbackThreeJsObject)
                    nodeChild.updateCallbackThreeJsObject(newChild, oldChild, this._renderingEngine.id);
                convertedObject.add(newChild);
                this.updateNode(nodeChild, newChild, filter, skeleton);
            }
            else if (objChild.SDversion !== nodeChild.version) {
                // if the version is different, update the child
                this.updateNode(nodeChild, objChild, filter, skeleton);
                objChild.SDversion = nodeChild.version;
            }
            else {
                this.updateNode(nodeChild, objChild, filter, skeleton);
            }
            // adjust the general BB
            if (!nodeChild.boundingBox.isEmpty())
                node.boundingBox.union(nodeChild.boundingBox);
            // adjust the specific BB
            if (nodeChild.boundingBoxViewport[this._renderingEngine.id] && !nodeChild.boundingBoxViewport[this._renderingEngine.id].isEmpty()) {
                // only do this if the node is
                // 1. visible
                // 2. no included in the "excludeViewports"
                // 3. if there are "restrictViewports", it needs to be in them
                if (node.visible && !node.excludeViewports.includes(this._renderingEngine.id) && !(node.restrictViewports.length > 0 && !node.restrictViewports.includes(this._renderingEngine.id))) {
                    node.boundingBoxViewport[this._renderingEngine.id].union(nodeChild.boundingBoxViewport[this._renderingEngine.id]);
                }
            }
        }
        convertedObject.visible = node.visible && !node.excludeViewports.includes(this._renderingEngine.id) && !(node.restrictViewports.length > 0 && !node.restrictViewports.includes(this._renderingEngine.id));
        convertedObject.applyTransformation(node.nodeMatrix);
    }
    updateSceneTree(root, lightEngine) {
        if (this._tree.root.version === this._lastRootVersion && this._renderingEngine.type === viewer_rendering_engine_rendering_engine_1.RENDERER_TYPE.STANDARD)
            return;
        this._lastRootVersion = this._tree.root.version;
        this._lastRendererType = this._renderingEngine.type;
        if (this._renderingEngine.closed)
            return;
        const oldBB = this._boundingBox.clone();
        this._boundingBox = new viewer_shared_math_1.Box();
        this._renderingEngine.lightLoader.shadowMapCount = 0;
        if (!this._mainNode) {
            this._mainNode = new SDObject_1.SDObject(root.id, root.version);
            const oldObj = root.threeJsObject[this._renderingEngine.id];
            root.threeJsObject[this._renderingEngine.id] = this._mainNode;
            if (root.updateCallbackThreeJsObject)
                root.updateCallbackThreeJsObject(this._mainNode, oldObj, this._renderingEngine.id);
            this._scene.add(this._mainNode);
        }
        this._boundingBoxSensitiveData = [];
        this._currentSDTFOverview = this.createSDTFOverview();
        this.updateNode(root, this._mainNode);
        this._boundingBox = root.boundingBoxViewport[this._renderingEngine.id].clone();
        for (let i = 0; i < this._boundingBoxSensitiveData.length; i++)
            this._renderingEngine.lightLoader.adjustToBoundingBox(this._boundingBoxSensitiveData[i].data, this._boundingBoxSensitiveData[i].dataChild, this._boundingBox);
        if (!(this._boundingBox.min[0] === oldBB.min[0] && this._boundingBox.min[1] === oldBB.min[1] && this._boundingBox.min[2] === oldBB.min[2] &&
            this._boundingBox.max[0] === oldBB.max[0] && this._boundingBox.max[1] === oldBB.max[1] && this._boundingBox.max[2] === oldBB.max[2])) {
            if (!this._stateEngine.renderingEngines[this._renderingEngine.id].boundingBoxCreated.resolved && !this._boundingBox.isEmpty())
                this._stateEngine.renderingEngines[this._renderingEngine.id].boundingBoxCreated.resolve(true);
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_CHANGE, {
                viewportId: this._renderingEngine.id, boundingBox: {
                    min: gl_matrix_1.vec3.clone(this._boundingBox.min),
                    max: gl_matrix_1.vec3.clone(this._boundingBox.max),
                }
            });
        }
        this._renderingEngine.renderingManager.evaluateTextureUnitCount(this._renderingEngine.lightLoader.shadowMapCount + this._renderingEngine.materialLoader.maxMapCount);
    }
    // #endregion Public Methods (6)
    // #region Private Methods (5)
    collectSDTFItemData(node) {
        for (let i = 0, len = node.data.length; i < len; i++)
            if (node.data[i] instanceof viewer_shared_types_1.SDTFItemData)
                return node.data[i];
        if (!node.parent)
            return;
        return this.collectSDTFItemData(node.parent);
    }
    createSDTFOverview(node = this._tree.root) {
        const out = new viewer_shared_types_1.SDTFOverviewData({});
        for (let i = 0, len = node.data.length; i < len; i++)
            if (node.data[i] instanceof viewer_shared_types_1.SDTFOverviewData)
                out.merge(node.data[i]);
        for (let i = 0, len = node.children.length; i < len; i++)
            out.merge(new viewer_shared_types_1.SDTFOverviewData(this.createSDTFOverview(node.children[i])));
        return out.overview;
    }
    getBone(node) {
        let bone;
        this._mainNode.traverse((o) => {
            if (o.SDid === node.id)
                bone = o;
        });
        return bone;
    }
    injectAttributeData(node, data) {
        const itemData = this.collectSDTFItemData(node);
        let visData = {
            material: new viewer_shared_types_1.MaterialStandardData({ color: '#199b9b', opacity: 1 }),
            matrix: gl_matrix_1.mat4.create()
        };
        if (this._renderingEngine.visualizeAttributes) {
            const userVisData = this._renderingEngine.visualizeAttributes(this._currentSDTFOverview, itemData);
            this._inputValidator.validateAndError(`Viewer.visualizeAttributes`, userVisData, 'object', true);
            this._inputValidator.validateAndError(`Viewer.visualizeAttributes`, userVisData.matrix, 'mat4', true);
            visData.material = userVisData.material;
            visData.matrix = visData.matrix;
        }
        node.addTransformation({
            id: 'sdtf',
            matrix: visData.matrix
        });
        if (data instanceof viewer_shared_types_1.GeometryData)
            data.primitive.attributeMaterial = visData.material;
    }
    removeData(dataObject) {
        switch (true) {
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.GEOMETRY:
                dataObject.traverse((o) => {
                    if (o instanceof THREE.Mesh) {
                        this._renderingEngine.geometryLoader.removeFromGeometryCache(o.geometry.userData.SDid + '_' + o.geometry.userData.SDversion);
                        this._renderingEngine.materialLoader.removeFromMaterialCache(o.material.userData.SDid + '_' + o.material.userData.SDversion);
                        for (const key in o.geometry.attributes)
                            o.geometry.deleteAttribute(key);
                        o.geometry.setIndex(null);
                        o.geometry.dispose();
                        for (let t in o.material) {
                            if (o.material[t] instanceof THREE.Texture) {
                                if (t !== 'envMap')
                                    o.material[t].dispose();
                            }
                        }
                        o.material.dispose();
                    }
                });
                break;
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.THREEJS:
                break;
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.MATERIAL:
                break;
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.LIGHT:
                dataObject.traverse((o) => {
                    if (o instanceof THREE.Light)
                        o.dispose();
                });
                break;
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.HTML_ELEMENT_ANCHOR:
                this._renderingEngine.htmlElementAnchorLoader.removeData(dataObject.SDid, dataObject.SDversion);
                break;
            case dataObject.SDtype === SDData_1.SD_DATA_TYPE.ANIMATION:
                break;
            default:
                // if there is no valid conversion here, call the convertData of the implementation
                break;
        }
    }
}
exports.SceneTreeManager = SceneTreeManager;
//# sourceMappingURL=SceneTreeManager.js.map